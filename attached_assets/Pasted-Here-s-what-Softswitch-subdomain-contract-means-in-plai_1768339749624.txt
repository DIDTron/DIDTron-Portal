Here’s what “Softswitch subdomain contract” means (in plain English), why it matters for speed/stability, and the exact block you paste to the Replit AI agent.

What it means (simple)

Right now you have two “worlds”:

Your platform DB world (Postgres) — what your UI reads fast.

ConnexCS world (external engine) — where calls are actually routed, rated, and CDRs are generated.

A subdomain contract is a written, strict agreement that defines, for each Softswitch concept:

What the entity is called

What fields we store in Postgres

What fields exist only in ConnexCS

What the source of truth is (DB vs ConnexCS)

How syncing works (push, pull, or both)

What ID mapping is used (local id ↔ connexcs id)

What “status states” exist (synced / pending / failed / degraded)

What endpoints exist and what they return (minimal list vs detail)

What background jobs exist for it

When you define that contract, the agent can build consistent code without guessing, and you avoid:

expensive deep joins,

duplicate data models,

“some pages read from ConnexCS live and become slow”,

and “rating breaks routing because they are coupled”.

Why it makes the portal faster

Because it forces a read-model design:

The UI reads fast tables in Postgres (minimal, indexed, paginated).

Any heavy or external work goes to DataQueue jobs.

ConnexCS is called mostly in the background, not while rendering pages.

So the portal stays quick even if ConnexCS is slow.

What you need to define (the actual contract sections)

You define it per subdomain:

1) Carrier subdomain

DB truth: carrier identity, roles (customer/supplier/bilateral), tenant ownership.

ConnexCS truth: engine-specific carrier identifiers/settings.

Sync: push changes to ConnexCS, pull back current engine state.

2) Interconnect subdomain (SIP trunk)

DB truth: name, direction, capacity, auth settings, codecs, IP lists.

ConnexCS truth: actual trunk object and runtime validation.

Sync: push config, pull status/health.

3) Service subdomain (the Digitalk “linker”)

This is the most important one.

Service = attaches interconnect to rating plan + routing plan + rules (direction, tech prefix, priorities).

DB truth: all service configuration and relationships.

ConnexCS truth: actual execution configuration once pushed.

4) Rating subdomain

DB truth: rate card versions, business rules, exceptions.

ConnexCS truth: rated call results and engine-side rating plan objects.

Sync: upload/push rate cards to ConnexCS via jobs, never in request.

UI reads from DB read model, not ConnexCS.

5) Routing subdomain

DB truth: routing plan, route groups, priorities, match lists.

ConnexCS truth: runtime routing tables.

Sync: push routing via jobs.

6) CDR/CRD ingestion subdomain

ConnexCS truth: CDR source.

DB truth: stored CDR/CRD, incremental sync cursor/high-water mark.

Sync: pull via jobs, batched, partitioned.

Where to put it in your docs (so it becomes “forever truth”)

This contract belongs in:

docs/DB_SCHEMA.md (because it defines canonical entities + mapping)
and

docs/UI_SPEC.md (because it defines what UI reads and which pages are list vs detail)
and a decision log entry in:

docs/DECISIONS.md

You do not create a new doc file.

Exactly what to say to the Replit AI agent (copy/paste)
DOC TARGET: docs/DB_SCHEMA.md / Softswitch Subdomain Contract (DB vs ConnexCS)
Define the Softswitch contract so there is zero ambiguity and no slow accidental joins/live ConnexCS reads.

For each entity: Carrier, Interconnect, Service, RatingPlan, RoutingPlan, CDR/CRD Sync:
1) Definition: what it is in Digitalk terms
2) Canonical source of truth (DB vs ConnexCS) per field group
3) DB tables involved (table names + key columns)
4) ConnexCS mapping (connexcsEntityMap usage; which ConnexCS object corresponds)
5) Sync model:
   - push (DB -> ConnexCS) actions
   - pull (ConnexCS -> DB) actions
   - job type names (DataQueue), batching rules, and cursors/high-water marks where needed
6) Status model:
   - synced / pending_sync / failed_sync / degraded_connexcs
   - how UI shows status and how errors are persisted
7) API shape:
   - list endpoints minimal payload + cursor pagination + max limit
   - detail endpoints for deep data
   - tab endpoints only fetch when tab active (do not load all)
8) Index strategy for hot queries and sorts (tenant_id-first where applicable)

DOC TARGET: docs/UI_SPEC.md / Softswitch Module Data Loading Rules
Add rules:
- UI must read from DB read models (fast), not live ConnexCS.
- Any write/push/sync triggers DataQueue job and returns jobId.
- Tabs are embedded but fetch only the active tab (enabled flag) + prefetch adjacent tabs.
- Large grids always virtualized; destinations/rates always search+limit+cursor.

DOC TARGET: docs/DECISIONS.md
Append: “Adopted Softswitch subdomain contract: DB read models + DataQueue push/pull; ConnexCS called via adapter/jobs; failure isolation between rating/routing/billing.”

Then update docs/TODO.md:
- Create/confirm a Plan ID and add tasks (dedupe first) to implement any missing pieces required by the contract.
- Do not code until contract is written and tasks exist.

The benefit you get immediately

Once that contract is written, you can tell the agent:

“Build carrier interconnect tab X”
and it will already know:

what table to read,

which endpoint should be list vs detail,

how to sync to ConnexCS,

how to show “pending sync” state,

and which indexes/pagination rules are mandatory.

That’s what makes it fast and stable.